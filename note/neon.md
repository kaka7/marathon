  建议的NEON调优步骤

    理清所需的寄存器、指令。 建议根据要实现的任务，画出数据变换流程，和每步所需的具体指令，尽可能找到最优的实现流程。这一步非常关键，如果思路出错或是不够优化，则会影响使用NEON的效果，并且对程序修改带来麻烦，一定要找到最优的实现算法哦~
    先实现intrinsics（可选）。 初学者先实现intrinsics是有好处的，字面理解性更强，且有助于理解NEON指令。建议随时打印关键步骤的数据，以检查程序的正误。
    写成汇编进一步优化。 将intrinsics生成的汇编代码进行优化调整。一般来说，有以下几点值得注意【干货】：

    只要intrinsics运算指令足够精简，运算类的汇编指令就不用大修；

    大部分的问题会出在存取、移动指令的滥用、混乱使用上；

    优化时要尽量减少指令间的相关性，包括结构相关、数据相关控制相关，保证流水线执行效率更高；

    大概估算所有程序指令取指、执行、写回的总理论时间，以此估算本程序可以优化的空间；

    熟练对每条指令准备发射、写回时间有一定的认识，有助于对指令的优化排序；

    一定要多测试不同指令的处理时间！！原因是你所想跟实际有出入，且不同的编译器优化的效果可能也有些不同；

    一定要有一定的计算机体系结构基础，对存储结构、流水线有一定的体会！！

总结一下NEON优化就是：

    第一优化算法实现流程；
    第二优化程序存取；
    第三优化程序执行；
    第四哪儿能优化，就优化哪儿

需要注意的地方

   load数据的时候，第一次load会把数据放在cache里面，只要不超过cache的大小，下一次load同样数据的时候，则会比第一次load要快很多，会直接从cache中load数据，这样在汇编程序设计的时候是非常需要考虑的问题。

   如：求取一个图像的均值，8*8的窗口，先行求和，然后列求和出来均值，这时候会有两个函数，数据会加载两遍，如果按照这样去优化的话则优化不了多少。如果换成上面这种思路，先做行16行，然后再做列，这样数据都在cache里面，做列的时候load数据会很快。

   在做neon乘法指令的时候会有大约2个clock的阻塞时间，如果你要立即使用乘法的结果，则就会阻塞在这里，在写neon指令的时候需要特别注意。乘法的结果不能立即使用，可以将一些其他的操作插入到乘法后面而不会有时间的消耗。
如：
vmul.u16 q1, d3, d4 
vadd.u32 q1, q2, q3
此时直接使用乘法的结果q1则会阻塞，执行vadd需要再等待2个clock的时间
使用饱和指令的时候，如乘法饱和的时候，在做乘法后会再去做一次饱和，所以时间要比直接做乘法要慢。
如： 
 vmul.u16 q1, d3, d4
vqmul.u32 q1, q2, q3
后一个的时间要比第一个的时间要久。
在对16位数据进行load或者store操作的时候，需要注意的是字节移位。比如是16位数据，则load 8个16位数据，如果指定寄存器进行偏移，此时需要特别注意。

例如：vld1.64 {d0}, [r0], r1


第一个数字代表的是数据类型宽度为8/16/32/64位，第二个数字代表的是一个寄存器中该类型数据的数量。如int16x8_t代表16位有符号数，寄存器中共有8个数据。
V{<mod模式>}<op操作>{<shape指令类型>}{<cond条件>}{.<dt数据类型>}{<dest目标地址>}, src1, src2

优势：使用内联函数进行优化，开发人员无需关注寄存器分配和互锁等问题，这些都交由编译器处理，而且编写程序比较容易，优化后的性能相对较高。

不足：目前内联函数所提供的功能和灵活性仍远远比不上汇编指令，并且经过编译器编译后，会反复加载／存取寄存器数据，导致系统时钟的浪费。 
所有 ARM 指令的长度都是 32 位。 这些指令是按字对齐方式存储的，因此在ARM 状态下，指令地址的两个最低有效位始终为零。
采用汇编语言进行NEON(NEON 汇编（assembly）)的最底层优化，可以使优化性能最大化，但汇编语言比较灵活，手写汇编程序对开发人员来说具有较大挑战，如果使用不恰当，反而会影响优化性能。
通常应用于图像处理、音视频处理等等需要大量计算的场景。
    使用NEON主要有四种方法：

        NEON优化库(Optimized libraries)
        向量化编译器(Vectorizing compilers)
        NEON intrinsics
        NEON assembly

根据优化程度需求不同，第4种最为底层，若熟练掌握效果最佳，一般也会配合第3种一起使用。

    优化库 Libraries：直接在程序中调用优化库

OpenMax DL：支持加速视频编解码、信号处理、色彩空间转换等；

Ne10：一个ARM的开源项目，提供数学运算、图像处理、FFT函数等。

    向量化编译 Vectorizing compilers：GCC编译器的向量优化选项

在GCC选项中加入向量化表示能有助于C代码生成NEON代码，如‐ftree‐vectorize。

    NEON intrinsics：提供了一个连接NEON操作的C函数接口，编译器会自动生成相关的NEON指令，支持ARMv7或ARMv8平台。


 v<noen函数前缀>q<饱和操作>ops<具体操作>tyep<指令类型  q,l,w,n>_flag<标识  n,lane,high or low>_dtype<返回值类型或参数类型>
 add 加法 
mul 乘法 
sub 减法 
mla 乘加 
mls 乘减 
ceq 比较，类似与 == 
cge 比较，类似与 >= 
cle 比较，类似与 <= 
cgt 比较，类似与 > 
clt 比较，类似与 < 
tst 做与运算后，判断是否等于0 ,ri = (ai & bi != 0) ? 1…1:0…0; 
abd 两个向量相减后的绝对值，vabd -> ri = |ai - bi|; 
max 求最大值，ri = ai >= bi ? ai : bi; 
min 求最小值，ri = ai >= bi ? bi : ai; 
shl 左移位， ri = ai << b; 
shr 右移位， ri = ai >> b; 
abs 求绝对值，ri = |ai|; 
neg 取反，ri = -ai; 
mvn 按位取反，ri = ~ai; 
and 与运算，ri = ai & bi; 
orr 或运算，ri = ai | bi; 
eor 异或运算，ri = ai ^ bi; 
cls 计算连续相同的位数 
get 取值，从向量中取出一个值，所谓的向量可以认为是一个数组，给数组中的某个元素赋值 
set 赋值，给向量中赋值 
dup 构造一个向量，并赋上初始值，ri = a; 
combine 合并操作，把两个向量合并 
mov 改变数据类型，数据范围，比如把u8 变成u16，或者u16变成u8 
zip 压缩操作 
uzp 解压操作 
ld1 加载数据，给定的buffer 指针中拷贝数据，注意是ld后面的是数字1，而不是字母l 
st1 拷贝数据，将neon数据类型拷贝到指定buffer中

〉示例函数指令分析

int16x8_t vqaddq_s16 (int16x8_t, int16x8_t)
int16x4_t vqadd_s16 (int16x4_t, int16x4_t)

    第一个字母'v'指明是vector向量指令，也就是NEON指令；
    第二个字母'q'指明是饱和指令，即后续的加法结果会自动饱和；
    第三个字段'add'指明是加法指令；
    第四个字段'q'指明操作寄存器宽度，为'q'时操作QWORD, 为128位；未指明时操作寄存器为DWORD，为64位；
    第五个字段's16'指明操作的基本单元为有符号16位整数，其最大表示范围为-32768 ~ 32767；
    第六个字段为空，普通指令，形参和返回值类型约定与C语言一致。

其它可能用到的助记符包括:

    l 长指令，数据扩展，双字运算得到四字结果
    w 宽指令，数据对齐，双字和四字运算得到四字结果
    n 窄指令, 数据压缩，四字运算得到双字结果

    示例2

uint8x8_t vld1_u8 (const uint8_t *)

    第一个字母'v'指明是vector向量指令，也就是NEON指令；
    第二个字段'ld'表示加载指令 load
    第三个字段'1'(注意是1，不是l)表示顺次加载。如果需要处理图像的RGB分量，可能会用到vld3间隔3个单元加载。

NEON指令按照作用可以分为：加载数据、存储数据、加减乘除运算、逻辑AND/OR/XOR运算、比较大小运算

vld1q_f32(r0);//将r0开头的4个连续地址存放的数据load到neon寄存器
饱和指令：当超过数据类型指定到范围则自动限制在该范围内 ,前一个q是饱和